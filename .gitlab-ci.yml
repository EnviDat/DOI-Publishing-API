stages:
  - build
  - package
  - deploy
  - manual-deploy

variables:
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  CACHE_COMPRESSION_LEVEL: "fast"

.triggers:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "pipeline"'
      when: never
    - if: $CI_COMMIT_REF_NAME == "main"
      when: always
    - if: $CI_COMMIT_REF_NAME == "staging"
      when: always
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always

set-vars:
  stage: .pre
  environment: $CI_COMMIT_REF_NAME
  image: docker.io/alpine:3.23
  script:
    - echo "DATACITE_DATA_URL_PREFIX=$DATACITE_DATA_URL_PREFIX" >> build.env
    - echo "DOI_PREFIX=$DOI_PREFIX" >> build.env
    - echo "DATACITE_API_URL=$DATACITE_API_URL" >> build.env
    - echo "DOI_SUFFIX_TAG=$DOI_SUFFIX_TAG" >> build.env
    - echo "INTERNAL_REG=$INTERNAL_REG"
    - echo "APP_NAME=$CI_PROJECT_NAME-$CI_COMMIT_REF_NAME" >> build.env
    - "echo APP_IMAGE=$INTERNAL_REG/$CI_PROJECT_NAME:\
      $APP_VERSION-$CI_COMMIT_REF_NAME >> build.env"
    - "echo PROXY_IMAGE=$INTERNAL_REG/$CI_PROJECT_NAME/proxy:\
      $NGINX_IMG_TAG-$CI_COMMIT_REF_NAME >> build.env"
  artifacts:
    reports:
      dotenv: build.env
    paths:
      - build.env

.build:
  stage: build
  image: docker:24.0.5
  environment: $CI_COMMIT_REF_NAME
  needs:
    - set-vars
  services:
    - name: docker:24.0.5-dind
      pull_policy: if-not-present
      # the following setting is for tls disabled
      #command: ["--tls=false"]
      # the following setting is for tls enabled
      command: [ "--tls=true", "--host=tcp://0.0.0.0:2376" ]
  variables:
    DOCKER_AUTH_CONFIG: $DOCKER_AUTH_CONFIG
    # the following settings are for tls disabled
    #DOCKER_HOST: tcp://docker:2375
    #DOCKER_TLS_CERTDIR: ""
    # the following settings are for tls enabled
    DOCKER_HOST: "tcp://docker:2376"
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    DOCKER_TLS_VERIFY: "1"
  tags:
    - dind
  before_script:
    - echo "Waiting for Docker daemon..."
    - until docker info >/dev/null 2>&1; do sleep 1; done
    - mkdir -p ~/.docker
    - echo "$DOCKER_AUTH_CONFIG" > ~/.docker/config.json
    - docker info
  script:
    - echo "CONTEXT_DIR=$CONTEXT_DIR"
    - cd $CONTEXT_DIR
    - docker build -t "${IMAGE_NAME}-unverified" --build-arg EXTERNAL_REG=$EXTERNAL_REG --build-arg PYTHON_IMG_TAG=$PYTHON_IMG_TAG --build-arg APP_VERSION=$APP_VERSION --build-arg NGINX_IMG_TAG=$NGINX_IMG_TAG .
    - docker push "${IMAGE_NAME}-unverified"


app-build:
  extends:
    - .triggers
    - .build
  variables:
    IMAGE_NAME: $APP_IMAGE
    CONTEXT_DIR: "$CI_PROJECT_DIR"

proxy-build:
  extends:
    - .triggers
    - .build
  variables:
    IMAGE_NAME: $PROXY_IMAGE
    CONTEXT_DIR: "$CI_PROJECT_DIR/nginx"


.retag:
  stage: package
  environment: $CI_COMMIT_REF_NAME
  image: docker.io/regclient/regctl:alpine
  variables:
    GIT_STRATEGY: none
  before_script:
    - export REG_HOST=${CI_REGISTRY}
    - >
      echo "{\"hosts\":{\"${REG_HOST}\":{\"tls\":\"enabled\",\"hostname\":
      \"${REG_HOST}\",\"user\":\"${CI_DEPLOY_USER}\",\"pass\":
      \"${CI_DEPLOY_PASSWORD}\"}}}" >> /home/appuser/.regctl/config.json
  script:
    - >
      regctl --verbosity debug image copy
      "${IMAGE_NAME}-unverified" "${IMAGE_NAME}"

app-retag:
  extends:
    - .triggers
    - .retag
  variables:
    IMAGE_NAME: $APP_IMAGE

proxy-retag:
  extends:
    - .triggers
    - .retag
  variables:
    IMAGE_NAME: $PROXY_IMAGE

remote-docker:
  stage: deploy
  needs:
      - job: set-vars
        artifacts: true
      - job: app-build
      - job: proxy-build
      - job: app-retag
      - job: proxy-retag
  environment: $CI_COMMIT_REF_NAME
  image: docker.io/docker:24.0
  extends:
    - .triggers
  variables:
    DOCKER_HOST: "ssh://$DEPLOY_SSH_USER@$DEPLOY_HOSTNAME"
    DOCKER_CONFIG: "$CI_PROJECT_DIR/.docker"
  before_script:
    - echo "***The app image is  $APP_IMAGE"

    # Create Docker config dir inside job container
    - mkdir -p "$DOCKER_CONFIG"
    - echo "$DOCKER_AUTH_CONFIG" > "$DOCKER_CONFIG/config.json"

    - echo "*** Going to docker compose remote with file 'docker-compose.$CI_COMMIT_REF_NAME.yml'"
    - echo "Adding SSH Key"
    - mkdir -p ~/.ssh
    - echo "$DEPLOY_SSH_KEY" >> ~/.ssh/gitlab
    - chmod 400 ~/.ssh/gitlab
    - echo 'IdentityFile ~/.ssh/gitlab' >> ~/.ssh/config
    - ssh-keyscan -H $DEPLOY_HOSTNAME >> ~/.ssh/known_hosts
  script:
    # create network envidat first if not present
    - >
      if ! docker network inspect envidat >/dev/null 2>&1; then 
        docker network create envidat
      fi

    # use docker compose create to recreate the container and force pulling the latest image
    # to avoid using the local cache

    - |
      docker compose --project-name="$APP_NAME" \
        --file "docker-compose.$CI_COMMIT_REF_NAME.yml" \
        --env-file build.env pull

    # use docker compose up to start the service on the remote machine
    - |
      docker compose --project-name="$APP_NAME" \
        --file "docker-compose.$CI_COMMIT_REF_NAME.yml" \
        --env-file build.env \
        up --detach --force-recreate

# Job for manual deploying of a docker-compose file, to use its
# docker images, make sure before you run it that the images referenced
# in the docker-compose.$CI_COMMIT_REF_NAME.yml exist!
manual-remote-docker:
  stage: manual-deploy
  needs:
    - job: set-vars
      artifacts: true
      optional: true
  environment: $CI_COMMIT_REF_NAME
  image: docker.io/docker:24.0
  rules:
    - if: '$CI_PIPELINE_SOURCE == "pipeline"'
      when: always
    - when: manual
  variables:
    DOCKER_HOST: "ssh://$DEPLOY_SSH_USER@$DEPLOY_HOSTNAME"
    DOCKER_CONFIG: "$CI_PROJECT_DIR/.docker"
  before_script:
    - echo "***The app image is  $APP_IMAGE"

    # Create Docker config dir inside job container
    - mkdir -p "$DOCKER_CONFIG"
    - echo "$DOCKER_AUTH_CONFIG" > "$DOCKER_CONFIG/config.json"
    - echo "With these environmental variables"

    - echo "*** Going to docker compose remote with file 'docker-compose.$CI_COMMIT_REF_NAME.yml'"
    - echo "Going to docker compose remote with file docker-compose.$CI_COMMIT_REF_NAME.yml"
    - echo "Adding SSH Key"
    - mkdir -p ~/.ssh
    - echo "$DEPLOY_SSH_KEY" >> ~/.ssh/gitlab
    - chmod 400 ~/.ssh/gitlab
    - echo 'IdentityFile ~/.ssh/gitlab' >> ~/.ssh/config
    - ssh-keyscan -H $DEPLOY_HOSTNAME >> ~/.ssh/known_hosts
  script:
    # create network envidat first if not present
    - >
      if ! docker network inspect envidat >/dev/null 2>&1; then 
        docker network create envidat
      fi
    # use docker compose create to recreate the container and force pulling the latest image
    # to avoid using the local cache
    - |
      docker compose --project-name="$APP_NAME"\
        --file "docker-compose.$CI_COMMIT_REF_NAME.yml" \
        --env-file build.env pull
    # use docker compose up to start the service on the remote machine
    - |
      docker compose --project-name="$APP_NAME"\
        --file "docker-compose.$CI_COMMIT_REF_NAME.yml" \
        --env-file build.env \
        up --detach --force-recreate
